# Домашнее задание 1: TypeScript

## Формулировка задания

В качестве задания предлагается реализовать типы (легкие, средние и сложные). За каждый реализованный тип вы будете получать определенное количество баллов. Чем выше набранный балл, тем выше ваша оценка.

Задания низкой сложности (+0.5 балла за каждое задание)

1. `MyPick<T, K>` - создает новый тип на основе исходного типа `T`, выбирая только те свойства, которые указаны в параметре `K`. Параметр `K` должен быть ключом типа `T`. Каждое свойство в новом типе копируется из исходного типа `T` с тем же именем и типом.
2. `NOfArray<ArrayObj, N>` - `ArrayObj` должен быть массивом, а `N` — индексом этого массива (числом). Тип возвращает элемент массива с индексом `N`.
3. `Unshift<ArrayType, Element>` - создает новый тип массива, где `Element` становится первым элементом, а оставшаяся часть массива - это исходный массив `ArrayType`.
4. `MyExclude<T, U>` - создает тип, исключая те элементы из `T`, которые присваиваются `U`. Если элемент `T` можно присвоить типу `U`, он исключается, иначе - сохраняется.

Задания средней сложности (+1 балл за каждое задание)

1. `DeepPartial<T>` - проходим по каждому ключу `T`. Если свойство - объект, делаем его опциональным и применяем `DeepPartial` рекурсивно. Если свойство — примитив (не объект), делаем его просто опциональным.
2. `MyCapitalize<T>` - разбиваем строку `T` на первую букву (`FirstLetter`) и остальные (`OtherLetters`). Если строка непуста, превращаем первую букву в заглавную с помощью `Uppercase`. Если строка пуста или не совпадает с шаблоном, возвращаем её как есть.
3. `DeepMutable<T>` - проходим по каждому ключу `T`. Убираем модификатор `readonly` с помощью `-readonly`. Если свойство - объект, применяем `DeepMutable` рекурсивно. Если свойство - примитив, просто делаем его изменяемым.
4. `ParseURLParams<StringElem>` - разбиваем строку на части: базовую (`Base`), параметр (`Parameter`) и остаток (`Remains`). Извлекаем параметр, затем рекурсивно вызываем для оставшейся части строки. Если это последний параметр, просто возвращаем его. Если нет параметров - возвращаем `never`.

Задания высокой сложности (+2 балла за каждое задание)

1. `Camelize<ObjectType>` - тип проходит по всем ключам объекта `ObjectType`. `as ToCamelCase<Extract<K, string>>` - каждый ключ `K` преобразуется в `camelCase` с помощью `ToCamelCase`. Поскольку ключи могут быть не строками, мы используем `Extract<K, string>`, чтобы оставить только строковые ключи. `ObjectType[K] extends object ?` - если значение свойства - объект, рекурсивно применяем `Camelize` ко вложенным объектам. Если значение не объект, оставляем его тип как есть. **[Дополнительно]** `ToCamelCase<S extends string>`:  `${infer A}_${infer B}` - если в строке есть символ `_`, разделяем строку на две части: до и после этого символа. `${A}${Capitalize<ToCamelCase<B>>}` - соединяем первую часть (`A`) с результатом рекурсивного вызова для второй части, где первая буква будет с заглавной. Если `_` нет, возвращаем строку как есть.
2. `DeepPick<T, Paths>` - `${infer Base}.${infer Other}` - если в строке пути есть точка, делим путь на две части: `Base` (первая часть пути) и `Other` (остальное). `Base extends keyof T` - если первая часть пути соответствует ключу в объекте `T`, извлекаем это свойство и рекурсивно применяем `DeepPick` к оставшейся части пути. Если путь целиком совпадает с ключом объекта, возвращаем это свойство. Если ключа нет, возвращаем `never`.

Также можно получить дополнительный балл за описание работы типа, если описание будет написано для всех типов, а также за удобство чтения кода.

При выполнении задания не запрещается редактировать исходный код слева от знаков присвоения.

Для выполнения задания допускается использование [официальной документации](https://typescriptlang.org), а также любых других источников, описывающих поведение типов. За использование ответов в открытом доступе (при нахождении таковых) вся работа аннулируется.

## Дедлайн

Сдача работы допускается в срок до 7 октября 2024г. 23:59:59. За каждый просроченный день итоговая оценка снижается на 1 балл.

## Порядок сдачи

Для сдачи работы на проверку необходимо склонировать задание в свой публичный репозиторий на github или gitlab, выполнить в нем задание скольким угодно числом коммитов и отправить ссылку на репозиторий в телеграм-канал "Домашние задания" с подписью <ФИО>_ДЗ-1. К проверке будет допущен последний выполененный коммит с рассчетом на просроченную сдачу.

Удачи в выполнении задания!
